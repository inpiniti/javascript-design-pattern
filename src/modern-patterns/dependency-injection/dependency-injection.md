# 의존성 주입 패턴

의존성 주입(DI)은 객체 간의 의존성을 외부에서 제공하는 소프트웨어 디자인 패턴입니다. 이 패턴은 객체가 자신이 필요로 하는 의존성을 직접 생성하는 대신, 외부 소스(일반적으로 DI 컨테이너)로부터 의존성을 주입받도록 합니다.

## 목적

의존성 주입의 주요 목적은 다음과 같습니다:

- 코드 결합도 감소
- 테스트 용이성 향상
- 코드 재사용성 증가
- 관심사 분리 촉진

## 사용 사례

의존성 주입은 다음과 같은 시나리오에서 유용합니다:

- 단위 테스트에서 목(mock) 객체를 주입할 때
- 애플리케이션 구성을 동적으로 변경해야 할 때
- 동일한 서비스의 다양한 구현을 전환해야 할 때

## 예제 코드

```javascript
// 서비스 클래스 정의
class 로그서비스 {
  로그기록(메시지) {
    console.log(`로그: ${메시지}`);
  }
}

class 데이터서비스 {
  데이터가져오기() {
    return ['데이터1', '데이터2', '데이터3'];
  }
}

// 의존성 주입을 사용하는 클래스
class 사용자서비스 {
  // 생성자를 통한 의존성 주입
  constructor(로그서비스, 데이터서비스) {
    this.로그서비스 = 로그서비스;
    this.데이터서비스 = 데이터서비스;
  }

  사용자가져오기() {
    this.로그서비스.로그기록('사용자 데이터 요청됨');
    return this.데이터서비스.데이터가져오기();
  }
}

// 의존성 주입 사용 예시
const 로그서비스인스턴스 = new 로그서비스();
const 데이터서비스인스턴스 = new 데이터서비스();

// 의존성 주입
const 사용자서비스인스턴스 = new 사용자서비스(
  로그서비스인스턴스,
  데이터서비스인스턴스
);

// 서비스 사용
const 사용자데이터 = 사용자서비스인스턴스.사용자가져오기();
console.log(사용자데이터);
```

위 예제에서 `사용자서비스` 클래스는 `로그서비스`와 `데이터서비스`에 의존하지만, 이러한 의존성을 직접 생성하는 대신 생성자를 통해 주입받습니다. 이렇게 하면 다음과 같은 이점이 있습니다:

1. 테스트 용이성: 테스트 시 실제 서비스 대신 목(mock) 서비스를 주입할 수 있습니다.
2. 유연성: 서비스의 구현을 변경하지 않고도 다양한 구현체를 주입할 수 있습니다.
3. 결합도 감소: `사용자서비스`는 의존하는 서비스의 구체적인 구현 세부 정보에 대해 알 필요가 없습니다.
